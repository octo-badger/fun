<!--
    Simple self-contained, single-file image reference viewer. 
    Features pinch-zoom and grid overlay, load local image files, flip horizontal.
    using https://remixicon.com/
-->
<html>
    <head>
        <!-- start STYLE -->
        <style>

            body 
            {
                touch-action: none;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                margin: 0px;
                overflow: hidden;
                height: 100vh;
                width: 100vw;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }

            #uiOverlay
            {
                align-self: end;
                z-index: 1;
            }

            #uiOverlay svg
            {
                width: 30px;
                height: 30px;
                border: 3px solid rgb(206, 194, 194);
                border-radius: 5px;
                padding: 3px;
                margin: 4px 2px;
                color: rgb(0, 225, 225);
                display: block;
            }

            #uiOverlay svg:hover { color: blueviolet; }
            #uiOverlay svg:active { color: black; }
            #uiOverlay svg.selected { color: rgb(255, 183, 0); }
            #uiOverlay svg.disabled { color: #ddd; }

            #uiOverlay div.break
            {
                border: 2px solid rgb(206, 194, 194);
                border-radius: 2px;
                margin: 10px;
            }
            
        
            img#reference
            {
                position: absolute;
                height: 100vh;
                /* width: 100vw;
                object-fit: contain; */
                z-index: -1;
            }

            canvas#grid
            {
                position: absolute;
                /* background-color: blue; */
                /* height: 99vh;
                width: 99vw; */
            }

            .hidden
            {
                display: none !important;
            }

            .flipped
            {
                transform: scaleX(-1);
            }

            div 
            {            
                position: relative;
                margin-top: 2px;
            }

            div[title]:hover::after 
            {
                background-color: rgb(255, 183, 0);
                padding: 7px 15px;
                border-radius: 10px;
                content: attr(title);
                position: absolute;
                top: 15%;
                left: -450%;
                white-space: nowrap;
                opacity: 80%;
            }

        </style>
        <!-- end STYLE -->
    </head>
    <body>
        <!-- start UI -->
        <div id="uiOverlay"> 
            <!-- <svg id="undo" viewBox="0 0 24 24" fill="currentColor"><path d="M5.82843 6.99955L8.36396 9.53509L6.94975 10.9493L2 5.99955L6.94975 1.0498L8.36396 2.46402L5.82843 4.99955H13C17.4183 4.99955 21 8.58127 21 12.9996C21 17.4178 17.4183 20.9996 13 20.9996H4V18.9996H13C16.3137 18.9996 19 16.3133 19 12.9996C19 9.68584 16.3137 6.99955 13 6.99955H5.82843Z"></path></svg> -->
            <div title="pinch-zoom image"><svg id="image" class="selected" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg></div>
            <div title="pinch-zoom grid"><svg id="grid" viewBox="0 0 24 24" fill="currentColor"><path d="M14 10H10V14H14V10ZM16 10V14H19V10H16ZM14 19V16H10V19H14ZM16 19H19V16H16V19ZM14 5H10V8H14V5ZM16 5V8H19V5H16ZM8 10H5V14H8V10ZM8 19V16H5V19H8ZM8 5H5V8H8V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z"></path></svg></div>
            <div title="flip horizontal">
                <svg id="flip" viewBox="0 0 24 24" fill="currentColor"><path d="M11 2V22H13V2H11ZM2 6C2 4.89543 2.89543 4 4 4H7C8.10457 4 9 4.89543 9 6V18C9 19.1046 8.10457 20 7 20H4C2.89543 20 2 19.1046 2 18V6ZM20 6V18H17V6H20ZM17 4C15.8954 4 15 4.89543 15 6V18C15 19.1046 15.8954 20 17 20H20C21.1046 20 22 19.1046 22 18V6C22 4.89543 21.1046 4 20 4H17Z"></path></svg>
                <svg id="flop" class="hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M11 2V22H13V2H11ZM7 6V18H4L4 6H7ZM4 4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H7C8.10457 20 9 19.1046 9 18V6C9 4.89543 8.10457 4 7 4H4ZM15 6C15 4.89543 15.8954 4 17 4H20C21.1046 4 22 4.89543 22 6V18C22 19.1046 21.1046 20 20 20H17C15.8954 20 15 19.1046 15 18V6Z"></path></svg>
            </div>
            <div class="break"></div>
            <div title="browse files"><svg id="browseFile" viewBox="0 0 24 24" fill="currentColor"><path d="M15 8V4H5V20H19V8H15ZM3 2.9918C3 2.44405 3.44749 2 3.9985 2H16L20.9997 7L21 20.9925C21 21.5489 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5447 3 21.0082V2.9918ZM11 9.5C11 10.3284 10.3284 11 9.5 11C8.67157 11 8 10.3284 8 9.5C8 8.67157 8.67157 8 9.5 8C10.3284 8 11 8.67157 11 9.5ZM17.5 17L13.5 10L8 17H17.5Z"></path></svg></div>
            <!--             
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M14 10V14H10V10H14ZM16 10H21V14H16V10ZM14 21H10V16H14V21ZM16 21V16H21V20C21 20.5523 20.5523 21 20 21H16ZM14 3V8H10V3H14ZM16 3H20C20.5523 3 21 3.44772 21 4V8H16V3ZM8 10V14H3V10H8ZM8 21H4C3.44772 21 3 20.5523 3 20V16H8V21ZM8 3V8H3V4C3 3.44772 3.44772 3 4 3H8Z"></path></svg>
                <svg width="16" height="16" fill="currentColor" class="bi bi-align-center" viewBox="0 0 16 16">
                    <path d="M8 1a.5.5 0 0 1 .5.5V6h-1V1.5A.5.5 0 0 1 8 1m0 14a.5.5 0 0 1-.5-.5V10h1v4.5a.5.5 0 0 1-.5.5M2 7a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1z"/>
                </svg>
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20.0834 10.4999L21.2855 11.2212C21.5223 11.3633 21.599 11.6704 21.457 11.9072C21.4147 11.9776 21.3559 12.0365 21.2855 12.0787L12.0001 17.6499L2.71463 12.0787C2.47784 11.9366 2.40106 11.6295 2.54313 11.3927C2.58536 11.3223 2.64425 11.2634 2.71463 11.2212L3.91672 10.4999L12.0001 15.3499L20.0834 10.4999ZM20.0834 15.1999L21.2855 15.9212C21.5223 16.0633 21.599 16.3704 21.457 16.6072C21.4147 16.6776 21.3559 16.7365 21.2855 16.7787L12.5145 22.0412C12.1979 22.2313 11.8022 22.2313 11.4856 22.0412L2.71463 16.7787C2.47784 16.6366 2.40106 16.3295 2.54313 16.0927C2.58536 16.0223 2.64425 15.9634 2.71463 15.9212L3.91672 15.1999L12.0001 20.0499L20.0834 15.1999ZM12.5145 1.30864L21.2855 6.5712C21.5223 6.71327 21.599 7.0204 21.457 7.25719C21.4147 7.32757 21.3559 7.38647 21.2855 7.42869L12.0001 12.9999L2.71463 7.42869C2.47784 7.28662 2.40106 6.97949 2.54313 6.7427C2.58536 6.67232 2.64425 6.61343 2.71463 6.5712L11.4856 1.30864C11.8022 1.11864 12.1979 1.11864 12.5145 1.30864Z"></path></svg>
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 8V16H16V8H8ZM6 6H18V18H6V6ZM6 2H8V5H6V2ZM6 19H8V22H6V19ZM2 6H5V8H2V6ZM2 16H5V18H2V16ZM19 6H22V8H19V6ZM19 16H22V18H19V16ZM16 2H18V5H16V2ZM16 19H18V22H16V19Z"></path></svg> 
            -->
            <div class="break"></div>
            <div title="lock pinch-zoom"><svg id="unlocked" viewBox="0 0 24 24" fill="currentColor"><path d="M7 10H20C20.5523 10 21 10.4477 21 11V21C21 21.5523 20.5523 22 20 22H4C3.44772 22 3 21.5523 3 21V11C3 10.4477 3.44772 10 4 10H5V9C5 5.13401 8.13401 2 12 2C14.7405 2 17.1131 3.5748 18.2624 5.86882L16.4731 6.76344C15.6522 5.12486 13.9575 4 12 4C9.23858 4 7 6.23858 7 9V10ZM10 15V17H14V15H10Z"></path></svg></div>
            <div title="unlock pinch-zoom"><svg id="locked" class="hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M19 10H20C20.5523 10 21 10.4477 21 11V21C21 21.5523 20.5523 22 20 22H4C3.44772 22 3 21.5523 3 21V11C3 10.4477 3.44772 10 4 10H5V9C5 5.13401 8.13401 2 12 2C15.866 2 19 5.13401 19 9V10ZM17 10V9C17 6.23858 14.7614 4 12 4C9.23858 4 7 6.23858 7 9V10H17ZM11 14V18H13V14H11Z"></path></svg></div>
        </div>
        <canvas id="grid"></canvas>
        <!-- end UI -->
        <img id="reference" src="./resources/octo-240218.png" />
    </body>
    <script>
        
        const body = document.querySelector("body");
        let img = document.querySelector('img#reference');

        // start SCRIPT ---
        
        const canvas = document.querySelector('canvas#grid');
        const maxDimension = Math.max(body.clientWidth, body.clientHeight) * 3;
        canvas.width = maxDimension;
        canvas.height = maxDimension;
        const context = canvas.getContext("2d");
        const eventCache = new Map();

        let pinch = {};
        let pinchTarget = img;
        
        const state = {
            img: {
                height: img.style.height,
                left: img.style.left,
                top: img.style.top,
            },
            canvas: {
                height: canvas.style.height,
                left: canvas.style.left,
                top: canvas.style.top,
            }
        };
        
        
        function pointerdownHandler(e)
        {
            e.preventDefault();
            let id = e.pointerId;

            eventCache.set(id, e);
            checkPinch();

            console.debug(`down id:${id}: `, e);
        }


        function pointerupHandler(e)
        {
            e.preventDefault();
            let id = e.pointerId;

            if(eventCache.delete(id))                           // will be false if the key didn't exist (not sure how that would happen, but moz always check in the examples)
            {
                checkPinch();
                console.debug(`up id:${id}: `, e);
            }
        }

        function checkPinch()
        {
            console.log('checkPinch');
            pinch = null;                                                               // we always want to reset when pointer events are added or deleted 
            if(eventCache.size === 2)                                                   // if we have exactly 2 pointer events...
            {
                /*
                const [key1, key2] = Array.from(eventCache.keys());                         // get both keys
                const [e1, e2] = [eventCache.get(key1), eventCache.get(key2)];              // is this neater? ... it's more concise because it would otherwise be 2 lines, but harder to read. Not sure I like it but it is a thing
                /*/
                //const [e1, e2] = Array.from(eventCache.values());                           // get both values
                const [e1, e2] = eventCache.values();                                       // get both values (event objects)
                //*/
                const {midX, midY} = calcMidpoint(e1, e2);
                
                console.log(`midX: ${pad(midX)}, midY: ${pad(midY)}`);
                const t = pinchTarget;

                pinch = { 
                            // one: { id: key1, e: e1 }, 
                            // two: { id: key2, e: e2 }, 
                            start: {
                                distance: calcDistance(e1, e2),
                                width: t.width,
                                height: t.height,
                                // offsetX: midX - img.offsetLeft,
                                // offsetY: midY - img.offsetTop,
                                zoomCentreX: (midX - t.offsetLeft) / t.width,
                                zoomCentreY: (midY - t.offsetTop) / t.height
                            }
                        };

                console.log(`pinch dist: ${pinch.start.distance}, zoomCentreX: ${pinch.start.zoomCentreX}, zoomCentreY: ${pinch.start.zoomCentreY}`);
            }
        }


        function calcDistance(e1, e2)
        {
            // return Math.sqrt(Math.pow(e1.offsetX - e2.offsetX, 2) + Math.pow(e1.offsetY - e2.offsetY, 2));
            return Math.sqrt(Math.pow(e1.x - e2.x, 2) + Math.pow(e1.y - e2.y, 2));                              // pythag
        }

        const mid = (p1, p2) => Math.abs(p1 - p2) / 2 + Math.min(p1, p2);                           // calculate the centre point between two coordinate values - ie x1(300) and x2(40) = abs(40-300) / 2 + min(40, 300) = 170
        
        function calcMidpoint(e1, e2)
        {
            return { midX: mid(e1.x, e2.x), midY: mid(e1.y, e2.y) };
        }


        // let c = 0;
        // setInterval(() => {
        //     console.log(`${c} move events per second`);
        //     c = 0;
        // },1000)

        let pad = (num) => (Math.floor(num) + '').padStart(3, '0');


        function pointermoveHandler(e)
        {
            e.preventDefault();
            let id = e.pointerId;

            if(eventCache.has(id))
            {
                // c++;
                eventCache.set(id, e);                                                              // is this required? Is a new event created on move?

                if(eventCache.size === 2)
                {
                    // const events = Array.from(eventCache.values());      // Array.from is redundant - the later spread operator works the same on both the array the iterator 
                    const events = [...eventCache.values()];                // Array.from / spread isn't redundant, because the spread uses the iterator, leaving it broken for the second spread, so creating an array here is necessary
                    const {distance, width, height, zoomCentreX, zoomCentreY} = pinch.start;
                    let ori = distance;
                    let now = calcDistance(...events);
                    const {midX, midY} = calcMidpoint(...events);

                    //console.log(`original: ${pad(ori)}, now: ${pad(now)}`);

                    // const [e1, e2] = Array.from(eventCache.values());
                    // console.log(`1x: ${pad(e1.x)}, 2x: ${pad(e2.x)}, 1y: ${pad(e1.y)}, 2y: ${pad(e2.y)}, now: ${pad(now)}`);
                    let zoomRatio = (ori / now);                                                // ratio of the difference
                    let newWidth = width / zoomRatio;                                           // scale the width by the ratio
                    let newHeight = height / zoomRatio;                                         // scale the height by the ratio
                    const t = pinchTarget;

                    if(t.getContext)                                                            // if this is a canvas ...
                    {
                        t.width = newWidth;
                        t.height = newHeight;
                        
                        drawGrid(canvas.width, canvas.height, 27, 27, "#ccc");
                        drawGrid(canvas.width, canvas.height, 9, 9, "black");
                    }

                    t.style.height = `${newHeight}px`;
                    t.style.left = `${midX - (newWidth * zoomCentreX)}px`;
                    t.style.top = `${midY - (newHeight * zoomCentreY)}px`;
                }
            }
        }


        function drawGrid(canvasWidth, canvasHeight, hDivisions, vDivisions, colour)
        {
            context.beginPath();
            context.strokeStyle = colour;
            context.lineWidth = 1;

            let divWidth = canvasWidth / hDivisions;
            for (let i = 1; i < hDivisions; i++) 
            {
                const x = (divWidth*i) + 0.5;
                context.moveTo(x, 0);
                context.lineTo(x, canvasHeight);
            }
            
            let divHeight = canvasHeight / vDivisions;
            for (let i = 1; i < vDivisions; i++) 
            {
                const y = (divHeight*i) + 0.5;
                context.moveTo(0, y);
                context.lineTo(canvasWidth, y);
            }

            context.stroke();
        }


        function enableImage()
        {
            pinchTarget = document.querySelector('img#reference');
            buttonClass('hidden', 'locked');
            buttonClass('selected', 'image');
            buttonClass('', 'unlocked', 'grid');
        }

        function enableGrid()
        {
            pinchTarget = document.querySelector('canvas#grid');
            buttonClass('selected', 'grid');
            buttonClass('hidden', 'locked');
            buttonClass('', 'unlocked', 'image');
        }

        function lock()
        {
            pinchTarget = null;
            buttonClass('', 'locked');
            buttonClass('hidden', 'unlocked');
            buttonClass('disabled', 'image', 'grid');
        }

        const classList = (selector) => document.querySelector(selector).classList;

        function flipToggle()
        {
            classList('img#reference').toggle('flipped');
            buttonClassToggle('hidden', 'flip', 'flop');
        }


        // onresize = (event) => {
        //     canvas.width = body.clientWidth;
        //     canvas.height = body.clientHeight;
        //     drawGrid(canvas.width, canvas.height, 9, 9, "#ccc");
        //     drawGrid(canvas.width, canvas.height, 3, 3, "black");
        // };

        function buttonClass(clazz, ...buttons)
        {
            buttons.forEach(button => classList('svg#' + button).value = clazz);
        }
        function buttonClassToggle(clazz, ...buttons)
        {
            buttons.forEach(button => classList('svg#' + button).toggle(clazz));
        }

        let getFile = null;                                                                 // reference to an optional function (not used in tamperMonkey version)

        setTimeout(() =>
        {
            Object.entries({
                "svg#image": enableImage,
                "svg#grid": enableGrid,
                "svg#flip": flipToggle,
                "svg#flop": flipToggle,
                "svg#browseFile": getFile,
                "svg#locked": enableImage,
                "svg#unlocked": lock,
            })
            .forEach(([selector, func]) => 
                    {   
                        const element = document.querySelector(selector);               // get the element by selector
                        func ?                                                          // if the click function exists ...
                            (element.onclick = func) :                                      // wire up the click
                                (element.classList.value = 'hidden');                           // ELSE hide the button (tamperMonkey version will auto-hide any buttons if we don't package the click function (outside SCRIPT comment region))
                    });
            
            body.onpointerdown = pointerdownHandler;
            body.onpointermove = pointermoveHandler;
            body.onpointerup = pointerupHandler;
            body.onpointercancel = pointerupHandler;
            body.onpointerout = pointerupHandler;
            body.onpointerleave = pointerupHandler;

            drawGrid(canvas.width, canvas.height, 27, 27, "#ccc9");
            drawGrid(canvas.width, canvas.height, 9, 9, "#0009");
        }, 10);
        
        
        // end SCRIPT ---


        function timestamp()
        {
            let d = new Date();
            return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${d.toLocaleTimeString('default', timeOptions)}.${pad3(d.getMilliseconds())}`;
        }

        const pickerOpts = 
        {
            types: [{
                description: "Images",
                accept: { "image/*": [".png", ".gif", ".jpeg", ".jpg", ".tiff"] },
            }],
            excludeAcceptAllOption: false,
            multiple: false,
        };

        let currentFile = 'octo-240218.png';
        let imageList = [];

        /**
         * optional function:
         * open a file-picker and update the img with the selected file data, also save the file blob to indexDB
         */
        getFile = async function() 
        {
            try 
            {
                const [fileHandle] = await window.showOpenFilePicker(pickerOpts);
                const file = await fileHandle.getFile();
                let objUrl = window.URL.createObjectURL(file);
                console.log(objUrl);
                document.querySelector('img#reference').src = objUrl;
                currentFile = file.name;
                await saveImageToIndexedDB(file, currentFile);
                resetCanvas();
                saveState();
            }
            catch (err)
            {
                console.warn('File selection cancelled or failed:', err);
            }
        }

        
        function resetCanvas() 
        {
            // reset canvas
        }

        function saveState() 
        {
            //const imgRecord = imageList.find(i => i.name === currentFile) ?? { name: currentFile };
            const imgIdx = imageList.findIndex(i => i.name === currentFile);
            imgIdx === -1 ?
                 imageList.push({ name: currentFile, time: timestamp() }) :
                    imageList[imgIdx].time = timestamp();
                    
            localStorage.setItem('imgRefState', JSON.stringify(state));
            saveImageToIndexedDB(blob)
        }

        async function saveImageToIndexedDB(blob, refId) 
        {
            return new Promise((resolve, reject) => 
            {
                const request = indexedDB.open('imgRefDB', 1);
                
                request.onupgradeneeded = (e) => 
                {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('images')) {
                        db.createObjectStore('images');
                    }
                };
                
                request.onsuccess = (e) => 
                {
                    const db = e.target.result;
                    const tx = db.transaction('images', 'readwrite');
                    tx.objectStore('images').put(blob, refId);
                    resolve(refId);
                };
                
                request.onerror = () => reject(request.error);
            });
        }

    </script>
</html>